const Utils = require('../../utils/index');
const describe = require('mocha').describe;
const it = require('mocha').it;

let sut;
let fake_profile = Utils.closure();
let owner = Utils.closure();
let not_owner = Utils.closure();
let valid_project = Utils.closure();
let invalid_project = "595e3a961301a19a495aa64b";
let valid_concrete = Utils.closure();
let already_concrete = Utils.closure();
let invalid_concrete = "595e3a961301a19a495aa64b";

describe('projects.concretes.add', () => {
    beforeEach(() => {
        sut = require('../../index');
        return createProfile()
            .then(createOwners)
            .then(createConcretes)
            .then(createProjects);
    });

    afterEach(() => {
        return clearUsers()
            .then(clearProjects)
            .then(clearConcretes);
    });

    it('should fail if the issuer is not the owner', (done) => {
        sut.actions.projects.concretes.add({
            user: {id: not_owner},
            params: {
                id: valid_project.value().id
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'not.owner')
            .and.notify(done);
    });

    it('should fail if the project does not exist', (done) => {
        sut.actions.projects.concretes.add({
            user: owner.value(),
            params: {
                id: invalid_project
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'unprocessable.project')
            .and.notify(done);
    });

    it('should fail if at least one of the target is already added in the project', (done) => {
        sut.actions.projects.concretes.add({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                concretes: [
                    valid_concrete.value().id,
                    already_concrete.value().id
                ]
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'already.in.project')
            .and.notify(done);
    });

    it('should fail if at least one of the target does not exist', (done) => {
        sut.actions.projects.concretes.add({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                concretes: [
                    valid_concrete.value().id,
                    invalid_concrete
                ]
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'unprocessable.concretes')
            .and.notify(done);
    });

    it('should succeed if all information are correct', (done) => {
        sut.actions.projects.concretes.add({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                concretes: [
                    valid_concrete.value().id
                ]
            }
        })
            .should.be.fulfilled
            .and.notify(done);
    });

    it('should add the concretes to the project', (done) => {
        sut.actions.projects.concretes.add({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                concretes: [
                    valid_concrete.value().id
                ]
            }
        })
            .then(validateProject)
            .should.be.fulfilled
            .and.notify(done);

        function validateProject() {
            return sut.models.Project.findById(valid_project.value().id)
                .then(s => s.concretes.length === 2 ? true : Promise.reject())
        }
    });
});


function createProfile() {
    return sut.models.Profile.create({
        title: 'fake'
    })
        .then(fake_profile.assign);
}

function createOwners() {
    return sut.models.User.create({
        email: 'owner@digipolitan.com',
        password: 'password',
        company: 'Digipolitan',
        profile: fake_profile.value()
    })
        .then(owner.assign)
}

function createConcretes() {
    return Promise.all([
        not_owner,
        valid_concrete,
        already_concrete
    ]
        .map(createConcrete));

    function createConcrete(closure, index) {
        return sut.models.Concrete.create({
            owner: owner.value(),
            name: `concrete_${index}`,
            reference: 'reference'
        })
            .then(closure.assign);
    }
}

function createProjects() {
    return sut.models.Project
        .create({
            owner: owner.value().id,
            name: 'project',
            client: 'LAFARGE HOLCIM',
            address: {
                street: '36 Rue de la boustifaille',
                zip_code: '29160',
                city: 'Crozon',
                state: 'FR',
                country: 'France'
            },
            concretes: [already_concrete.value()]
        })
        .then(valid_project.assign)
}

function clearUsers() {
    return sut.models.User.remove();
}

function clearConcretes() {
    return sut.models.Concrete.remove();
}

function clearProjects() {
    return sut.models.Project.remove();
}