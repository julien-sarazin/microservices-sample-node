const Utils = require('../../utils/index');
const describe = require('mocha').describe;
const it = require('mocha').it;

let sut;
let fake_profile = Utils.closure();
let owner = Utils.closure();
let not_owner = Utils.closure();
let valid_project = Utils.closure();
let invalid_project = "595e3a961301a19a495aa64b";
let valid_collab = Utils.closure();
let already_collab = Utils.closure();
let invalid_collab = "595e3a961301a19a495aa64b";

describe('projects.collaborators.invite', () => {
    beforeEach(() => {
        sut = require('../../index');
        return createProfile()
            .then(createOwners)
            .then(createCollaborators)
            .then(createProjects);
    });

    afterEach(() => {
        return clearUsers()
            .then(clearProjects);
    });

    it('should fail if the issuer is not the owner', (done) => {
        sut.actions.projects.collaborators.invite({
            user: {id: not_owner},
            params: {
                id: valid_project.value().id
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'not.owner')
            .and.notify(done);
    });

    it('should fail if the project does not exist', (done) => {
        sut.actions.projects.collaborators.invite({
            user: owner.value(),
            params: {
                id: invalid_project
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'unprocessable.project')
            .and.notify(done);
    });

    it('should fail if at least one of the target is already a collaborator', (done) => {
        sut.actions.projects.collaborators.invite({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                collaborators: [
                    valid_collab.value().id,
                    already_collab.value().id
                ]
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'already.collaborator')
            .and.notify(done);
    });

    it('should fail if at least one of the target does not exist', (done) => {
        sut.actions.projects.collaborators.invite({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                collaborators: [
                    valid_collab.value().id,
                    invalid_collab
                ]
            }
        })
            .should.be.rejectedWith(Error)
            .and.eventually.have.property('message', 'unprocessable.collaborators')
            .and.notify(done);
    });

    it('should succeed if all information are correct', (done) => {
        sut.actions.projects.collaborators.invite({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                collaborators: [
                    valid_collab.value().id
                ]
            }
        })
            .should.be.fulfilled
            .and.notify(done);
    });

    it('should add the collaborators to the project', (done) => {
        sut.actions.projects.collaborators.invite({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                collaborators: [
                    valid_collab.value().id
                ]
            }
        })
            .then(validateProject)
            .should.be.fulfilled
            .and.notify(done);

        function validateProject() {
            return sut.models.Project.findById(valid_project.value().id)
                .then(s => s.collaborators.length === 2 ? true : Promise.reject())
        }
    });

    it('should add the project to the collaborators', (done) => {
        sut.actions.projects.collaborators.invite({
            user: owner.value(),
            params: {
                id: valid_project.value().id
            },
            data: {
                collaborators: [
                    valid_collab.value().id
                ]
            }
        })
            .then(validateCollaborator)
            .should.be.fulfilled
            .and.notify(done);

        function validateCollaborator() {
            return sut.models.User.findById(valid_collab.value().id)
                .then(u => (u.projects.length === 1) ? true : Promise.reject())
        }
    });
});


function createProfile() {
    return sut.models.Profile.create({
        title: 'fake'
    })
        .then(fake_profile.assign);
}

function createOwners() {
    return sut.models.User.create({
        email: 'owner@digipolitan.com',
        password: 'password',
        company: 'Digipolitan',
        profile: fake_profile.value()
    })
        .then(owner.assign)
}

function createCollaborators() {
    return Promise.all([
        not_owner,
        valid_collab,
        already_collab
    ]
        .map(createCollaborator));

    function createCollaborator(closure, index) {
        return sut.models.User.create({
            email: `collab_${index}@digipolitan.com`,
            password: 'password',
            company: 'Digipolitan',
            profile: fake_profile.value()
        })
            .then(closure.assign);
    }
}

function createProjects() {
    return sut.models.Project
        .create({
            owner: owner.value().id,
            name: 'project',
            client: 'LAFARGE HOLCIM',
            address: {
                street: '36 Rue de la boustifaille',
                zip_code: '29160',
                city: 'Crozon',
                state: 'FR',
                country: 'France'
            },
            collaborators: [already_collab.value()]
        })
        .then(valid_project.assign)
}

function clearUsers() {
    return sut.models.User.remove();
}

function clearProjects() {
    return sut.models.Project.remove();
}